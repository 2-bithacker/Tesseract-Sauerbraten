// standard shader definitions

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader 0 "default" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "rect" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2DRect(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "cubemap" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform samplerCube tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * textureCube(tex0, gl_TexCoord[0].xyz);
    }
]

shader 0 "rgbonly" [ 
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor.rgb = gl_Color.rgb * texture2D(tex0, gl_TexCoord[0].xy).rgb;
        gl_FragColor.a   = gl_Color.a;
    }
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader 0 "notexture" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
    }
] [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_MultiTexCoord0;
        gl_FrontColor = gl_Color;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy);
    }
]

shader 0 "foggednotexture" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
    }
] [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    void main() { gl_Position = ftransform(); } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
  stype = 1
  if (>= (strstr $arg1 "env") 0) [stype = (+ $stype 2)]
  loop i 2 [
    variantshader $stype $arg1 (? $i 0 -1) [
        #pragma CUBE2_fog
        @(if (>= $numargs 5) [result $arg5])
        uniform vec4 texgenscroll;
        varying vec3 normal;
        @(if $i [result [uniform vec4 blendmapparams;]])
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texgenscroll.xy;
            @(if $i [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = gl_Normal;

            @arg2
        }
    ] [
        @(if (>= $numargs 5) [result $arg5])
        @(if (>= $numargs 6) [result $arg6])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec3 normal;
        @(if $i [result [uniform sampler2D blendmap;]])
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, gl_TexCoord[0].xy);   

            @arg3

            @(if $i [result [
                float alpha = colorparams.a * texture2D(blendmap, gl_TexCoord[1].xy).r;
            ]] [result [
                #define alpha colorparams.a
            ]])
            
            gl_FragData[0] = vec4(diffuse.rgb*colorparams.rgb, alpha);
            gl_FragData[1] = vec4(normal*0.5+0.5, 0.0);
            @(if (|| (< $numargs 4) [=s $arg4 []]) [result [gl_FragData[2] = vec4(0.0);]] [result $arg4])
        }
    ]
  ]
]

worldshader "stdworld" [] []

defershader 1 "glowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  worldshader "glowworld" [] [] [
    vec3 glow = texture2D(glowmap, gl_TexCoord[0].xy).rgb;
    glow *= glowcolor.rgb;
    gl_FragData[2] = vec4(glow, 0.0);
  ] [] [uniform sampler2D glowmap;]
]

defershader 1 "pulseworld" [
  defuniformparam "pulsespeed" 1 // pulse frequency (Hz)
  worldshader "pulseworld" [
    pulse = abs(fract(millis.x * pulsespeed.x)*2.0 - 1.0); 
  ] [
    vec3 diffuse2 = texture2D(decal, gl_TexCoord[0].xy).rgb; 
    diffuse.rgb = mix(diffuse.rgb, diffuse2, pulse);
  ] [] [uniform vec4 millis; varying float pulse;] [uniform sampler2D decal;]
]

defershader 1 "pulseglowworld" [
  defuniformparam "glowcolor" 1 1 1 // glow color
  defuniformparam "pulseglowspeed" 1 // pulse frequency (Hz)
  defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
  worldshader "pulseglowworld" [
    pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis.x * pulseglowspeed.x)*2.0 - 1.0));
  ] [] [
    vec3 glow = texture2D(glowmap, gl_TexCoord[0].xy).rgb;
    gl_FragData[2] = vec4(glow*pulse, 0.0);
  ] [uniform vec4 millis; varying vec3 pulse;] [uniform sampler2D glowmap;]
]

defershader 3 "envworld" [
  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworld" [
    camvec = camera.xyz - gl_Vertex.xyz; 
  ] [
    vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvec, normal) - camvec).rgb;
  ] [
    gl_FragData[2] = vec4(reflect*envscale.x, envscale.x);
  ] [uniform vec4 camera; varying vec3 camvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldfast" [
    vec3 camvec = camera.xyz - gl_Vertex.xyz;
    rvec = 2.0*gl_Normal*dot(camvec, gl_Normal) - camvec;
  ] [
    vec3 reflect = textureCube(envmap, rvec).rgb;
  ] [
    gl_FragData[2] = vec4(reflect*envscale.x, envscale.x);
  ] [uniform vec4 camera; varying vec3 rvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldalt" [] []

  altshader envworld envworldalt
  fastshader envworld envworldfast 2
  fastshader envworld envworldalt 1
]

shader 0 "depthfxworld" [
    uniform vec4 depthscale, depthoffsets;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = depthoffsets - (gl_ModelViewMatrix * gl_Vertex).z*depthscale;
    }
] [
    void main(void)
    {
        gl_FragColor = gl_TexCoord[0];
    }
]

shader 0 depthfxsplitworld [
    uniform vec4 depthscale, depthoffsets;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = depthoffsets - (gl_ModelViewMatrix * gl_Vertex).z*depthscale;
    }
] [
    void main(void)
    {
        vec4 ranges = vec4(gl_TexCoord[0].x, fract(gl_TexCoord[0].yzw));
        ranges.xy -= ranges.yz*vec2(0.00390625, 0.00390625);
        gl_FragColor = ranges;
    }
]

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    b -> blendmap

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    stype = (? (btopt "e") 3 1)
    if (! (btopt "i")) [
        if (btopt "G") [
            defuniformparam "glowcolor" 1 1 1 // glow color
            defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
            defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
        ] [if (btopt "g") [
            defuniformparam "glowcolor" 1 1 1  // glow color
        ]]
        if (btopt "S") [
            defuniformparam "specscale" 6 6 6 // spec map multiplier
        ] [if (btopt "s") [
            defuniformparam "specscale" 1 1 1 // spec multiplier
        ]]
        if (|| (btopt "p") (btopt "P")) [
            defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
        ]
        if (btopt "R") [
            defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
        ] [if (btopt "r") [
            defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity 
        ]]
    ] [
        if (btopt "s") [stype = (+ $stype 8)]
    ]
    variantshader $stype $arg1 (? (btopt "b") 0 -1) [
        #pragma CUBE2_fog
        uniform vec4 texgenscroll;
        varying mat3 world;
        @(if (btopt "o") [result [uniform vec4 orienttangent, orientbinormal;]])
        @(if (|| (btopt "t") (btopt "r")) [result [uniform vec4 camera;]])
        @(if (btopt "t") [result [varying vec3 camvects;]])
        @(if (btopt "r") [result [varying vec3 camvecw;]])
        @(if (btopt "G") [result [uniform vec4 millis; varying float pulse;]])
        @(if (btopt "b") [result [uniform vec4 blendmapparams;]])
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texgenscroll.xy;

            @(if (btopt "b") [result [
                gl_TexCoord[1].xy = (gl_Vertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])

            vec4 tangent = gl_Color*2.0 - 1.0;
            vec3 binormal = cross(gl_Normal, tangent.xyz) * tangent.w;
            // calculate tangent -> world transform
            world = mat3(tangent.xyz, binormal, gl_Normal);
       
            @(if (btopt "t") [result [camvects = (camera.xyz - gl_Vertex.xyz) * world; ]])
            @(if (btopt "r") [result [camvecw = camera.xyz - gl_Vertex.xyz;]])

 
            @(if (btopt "G") [result [
                pulse = abs(fract(millis.x*pulseglowspeed.x)*2.0 - 1.0);
            ]])
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap, normalmap;
        varying mat3 world;
        @(if (btopt "t") [result [varying vec3 camvects;]])
        @(if (btopt "g") [result [uniform sampler2D glowmap;]])
        @(if (btopt "G") [result [varying float pulse;]])
        @(if (btopt "r") [result [uniform samplerCube envmap; varying vec3 camvecw;]])
        @(if (btopt "b") [result [uniform sampler2D blendmap;]])
        void main(void)
        {
            @(if (btopt "t") [result [vec3 camdirts = normalize(camvects);]])
            @(if (btopt "p") [result [
                float height = texture2D(normalmap, gl_TexCoord[0].xy).a;
                vec2 dtc = gl_TexCoord[0].xy + camdirts.xy*(height*parallaxscale.x + parallaxscale.y);
            ]])
            @(if (btopt "P") [result [
                const float step = -1.0/7.0;
                vec3 duv = vec3((step*parallaxscale.x/camdir.z)*camdirts.xy, step);
                vec3 htc = vec3(gl_TexCoord[0].xy + duv.xy*parallaxscale.y, 1.0);
                vec4 height = texture2D(normalmap, htc.xy);
                @@(loopconcat i 7 [concatword [
                    htc += height.w < htc.z ? duv : vec(0.0);
                    height = texture2D(normalmap, htc.xy);
                ]])
                #define dtc htc.xy
                #define bump height.xyz    
            ]])
            @(if (|| (btopt "p") (btopt "P")) [] [result [#define dtc gl_TexCoord[0].xy]])

            vec4 diffuse = texture2D(diffusemap, dtc);

            @(if (btopt "b") [result [
                float alpha = colorparams.a * texture2D(blendmap, gl_TexCoord[1].xy).r;
            ]] [result [
                #define alpha colorparams.a
            ]])

            gl_FragData[0] = vec4(diffuse.rgb*colorparams.rgb, alpha);

            @(if (! (btopt "P")) [result [vec3 bump = texture2D(normalmap, dtc).rgb;]])

            bump = world * (bump*2.0 - 1.0);

            gl_FragData[1].rgb = bump*0.5 + 0.5;

            @(if (btopt "s") [
                if (btopt "S") [result [
                    gl_FragData[1].a = diffuse.a*specscale.x * 0.5;
                ]] [result [
                    gl_FragData[1].a = specscale.x * 0.5;
                ]]
            ] [result [
                gl_FragData[1].a = 0.0;
            ]])

            @(if (|| (btopt "r") (btopt "g")) [result [
                @(if (btopt "g") [result [
                    vec3 glow = texture2D(glowmap, dtc).rgb;
                    @(if (btopt "G") [result [
                        vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
                    ]])
                    glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz"); 
                    @(if (! (btopt "r")) [result [
                        gl_FragData[2] = vec4(glow, 0.0);
                    ]])
                ]])
    
                @(if (btopt "r") [result [
                    vec3 rvec = 2.0*bump*dot(camvecw, bump) - camvecw;
                    vec3 reflect = textureCube(envmap, rvec).rgb;
                    @(if (btopt "R") [result [
                        float rmod = envscale.x*diffuse.a;
                    ]] [result [
                        #define rmod envscale.x
                    ]])
                    gl_FragData[2] = vec4(reflect*rmod, rmod);
                    @(if (btopt "g") [result [
                        gl_FragData[2].rgb += glow;
                    ]])
                ]])

            ]] [result [
                gl_FragData[2] = vec4(0.0);
            ]])
        }
    ]
]

bumpshader = [
    defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
        bumpvariantshader @arg1 @arg2
        bumpvariantshader @arg1 @(concatword $arg2 "b")
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

// skeletal animation for matrices and dual quaternions

skelanimdefs = [
    result [
        @(if $useubo [result [
            #ifdef GL_ARB_uniform_buffer_object
                #extension GL_ARB_uniform_buffer_object : enable
            #endif
        ]])
        @(if $usebue [result [
            #extension GL_EXT_bindable_uniform : enable
        ]]) 
        #pragma CUBE2_attrib vweights 6
        #pragma CUBE2_attrib vbones 7
        attribute vec4 vweights; 
        attribute vec4 vbones;
        #pragma CUBE2_uniform animdata AnimData 0 16
        @(if $useubo [result [
            #ifdef GL_ARB_uniform_buffer_object
                layout(std140) uniform AnimData
                {
                    vec4 animdata[@@(- (min (- $maxvsuniforms $reservevpparams) 256) 10)];
                };
            #else
        ]])
        @(if $usebue [result [
            #ifdef GL_EXT_bindable_uniform
                bindable
            #endif
        ]])
        uniform vec4 animdata[@@(- (min (- $maxvsuniforms $reservevpparams) 256) 10)];
        @(if $useubo [result [
            #endif
        ]])
    ]
]

skelanimfragdefs = [
    if $ati_ubo_bug [
        if $useubo [result [
            #ifdef GL_ARB_uniform_buffer_object
                #extension GL_ARB_uniform_buffer_object : enable
                layout(std140) uniform AnimData
                {
                    vec4 animdata[@@(- (min (- $maxvsuniforms $reservevpparams) 256) 10)];
                };
            #endif
        ]] [result [
            #ifdef GL_EXT_bindable_uniform
                #extension GL_EXT_bindable_uniform : enable
                bindable uniform vec4 animdata[@@(- (min (- $maxvsuniforms $reservevpparams) 256) 10)];
            #endif
        ]]
    ]
]

skelmatanim = [
    result [
        int index = int(vbones.x);
        @(if (= $arg1 1) [result [
            vec4 mx = animdata[index];
            vec4 my = animdata[index+1];
            vec4 mz = animdata[index+2];
        ]] [result [
            vec4 mx = animdata[index] * vweights.x;
            vec4 my = animdata[index+1] * vweights.x;
            vec4 mz = animdata[index+2] * vweights.x;
            index = int(vbones.y);
            mx += animdata[index] * vweights.y;
            my += animdata[index+1] * vweights.y;
            mz += animdata[index+2] * vweights.y;
        ]])
        @(if (>= $arg1 3) [result [
            index = int(vbones.z);
            mx += animdata[index] * vweights.z;
            my += animdata[index+1] * vweights.z;
            mz += animdata[index+2] * vweights.z;
        ]])
        @(if (>= $arg1 4) [result [
            index = int(vbones.w);
            mx += animdata[index] * vweights.w;
            my += animdata[index+1] * vweights.w;
            mz += animdata[index+2] * vweights.w;
        ]])

        vec4 opos = vec4(dot(mx, gl_Vertex), dot(my, gl_Vertex), dot(mz, gl_Vertex), gl_Vertex.w);

        @(if $arg2 [result [
            vec3 onormal = vec3(dot(mx.xyz, gl_Normal), dot(my.xyz, gl_Normal), dot(mz.xyz, gl_Normal));
        ]])

        @(if $arg3 [result [
            vec3 otangent = vec3(dot(mx.xyz, vtangent.xyz), dot(my.xyz, vtangent.xyz), dot(mz.xyz, vtangent.xyz));
        ]])
    ]
]

skelquatanim = [
    result [
        int index = int(vbones.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [ 
            vec4 dqreal = animdata[index] * vweights.x;
            vec4 dqdual = animdata[index+1] * vweights.x;
            index = int(vbones.y);
            dqreal += animdata[index] * vweights.y;
            dqdual += animdata[index+1] * vweights.y;
            @(if (>= $arg1 3) [result [
                index = int(vbones.z);
                dqreal += animdata[index] * vweights.z;
                dqdual += animdata[index+1] * vweights.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vbones.w);
                dqreal += animdata[index] * vweights.w;
                dqdual += animdata[index+1] * vweights.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 opos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, gl_Vertex.xyz) + gl_Vertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + gl_Vertex.xyz, gl_Vertex.w);

        @(if $arg2 [result [
            vec3 onormal = cross(dqreal.xyz, cross(dqreal.xyz, gl_Normal) + gl_Normal*dqreal.w)*2.0 + gl_Normal;
        ]])

        @(if $arg3 [result [
            vec3 otangent = cross(dqreal.xyz, cross(dqreal.xyz, vtangent.xyz) + vtangent.xyz*dqreal.w)*2.0 + vtangent.xyz;
        ]])
    ]
]

nocolormodelvertexshader = [
    result [
        @(? $arg3 [uniform vec4 tetramodelclip;])
        @(if (|| [strlen $arg1] [strlen $arg2]) [result [
            @arg1
            void main(void)
            {
                @arg2
                gl_Position = gl_ModelViewProjectionMatrix * opos;
        ]] [result [
            void main(void)
            {
                gl_Position = ftransform();
                #define opos gl_Vertex
        ]])
                @(? $arg3 [gl_ClipDistance[0] = dot(opos, tetramodelclip);]) 
            }
    ]
]

shader 0 nocolormodel (nocolormodelvertexshader) [
    void main(void)
    {
    }
]
shader 0 tetramodel (nocolormodelvertexshader [] [] 1) [
    void main(void)
    {
    }
]
loop i 4 [
    variantshader 0 nocolormodel 0 (nocolormodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelmatanim (+ $i 1) 0 0)) []
    variantshader 0 nocolormodel 1 (nocolormodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelquatanim (+ $i 1) 0 0)) []
    variantshader 0 tetramodel 0 (nocolormodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelmatanim (+ $i 1) 0 0) 1) []
    variantshader 0 tetramodel 1 (nocolormodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelquatanim (+ $i 1) 0 0) 1) []
]

notexturemodelvertexshader = [
    result [
        @(if (>= $numargs 2) [result [
            @arg1
            #pragma CUBE2_fog opos
            void main(void)
            {
                @arg2  
                gl_Position = gl_ModelViewProjectionMatrix * opos;
        ]] [result [
            #pragma CUBE2_fog
            void main(void)
            {
                gl_Position = ftransform();
        ]])
                gl_FrontColor = gl_Color;
            }
    ]
]

shader 0 notexturemodel (notexturemodelvertexshader) [
    void main(void)
    {
        gl_FragColor = gl_Color;
    }
]
loop i 4 [
    variantshader 0 notexturemodel 0 (notexturemodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelmatanim (+ $i 1) 0 0)) []
    variantshader 0 notexturemodel 1 (notexturemodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelquatanim (+ $i 1) 0 0)) []
]

alphashadowmodelvertexshader = [
    result [
        @(? $arg3 [uniform vec4 tetramodelclip;])
        uniform vec4 texscroll;
        @(if (|| [strlen $arg1] [strlen $arg2]) [result [
            @arg1
            void main(void)
            {
                @arg2
                gl_Position = gl_ModelViewProjectionMatrix * opos;
        ]] [result [
            void main(void)
            {
                gl_Position = ftransform();
                #define opos gl_Vertex
        ]])
                gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texscroll.yz;
                @(? $arg3 [gl_ClipDistance[0] = dot(opos, tetramodelclip);]) 
            }
    ]
]

shader 0 alphashadowmodel (alphashadowmodelvertexshader) [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = texture2D(tex0, gl_TexCoord[0].xy);
    }
]
shader 0 alphashadowtetramodel (alphashadowmodelvertexshader [] [] 1) [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = texture2D(tex0, gl_TexCoord[0].xy);
    }
]
loop i 4 [
    variantshader 0 alphashadowmodel 0 (alphashadowmodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelmatanim (+ $i 1) 0 0)) []
    variantshader 0 alphashadowmodel 1 (alphashadowmodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelquatanim (+ $i 1) 0 0)) []
    variantshader 0 alphashadowtetramodel 0 (alphashadowmodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelmatanim (+ $i 1) 0 0) 1) []
    variantshader 0 alphashadowtetramodel 1 (alphashadowmodelvertexshader (skelanimdefs (+ $i 1) 0 0) (skelquatanim (+ $i 1) 0 0) 1) []
]

// mdltype:
//    e -> envmap
//    n -> normalmap
//    s -> spec
//    m -> masks
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

modelvertexshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimdefs $arg2 1 (mdlopt "n")])
        #pragma CUBE2_fog opos
        @(if (mdlopt "n") [result [
            #pragma CUBE2_attrib vtangent 1
            attribute vec4 vtangent;
        ]])
        uniform vec4 camera, texscroll;
        @(if (mdlopt "n") [result [
            varying mat3 world;
            @(if (mdlopt "e") [result [
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                uniform vec4 envmapscale;
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        void main(void)
        {
            @(if (mdlopt "B") [skelmatanim $arg2 1 (mdlopt "n")])
            @(if (mdlopt "b") [skelquatanim $arg2 1 (mdlopt "n")])
            @(if (|| (mdlopt "b") (mdlopt "B")) [result [
                gl_Position = gl_ModelViewProjectionMatrix * opos;
            ]] [result [
                gl_Position = ftransform();
                #define opos gl_Vertex
                #define onormal gl_Normal
                #define otangent vtangent.xyz
            ]])

            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + texscroll.yz;
      
            @(if (|| (mdlopt "e") (mdlopt "s")) [result [
                vec3 camdir = normalize(camera.xyz - opos.xyz);
            ]])

            mat3 objmat = mat3(gl_TextureMatrix[0][0].xyz, gl_TextureMatrix[0][1].xyz, gl_TextureMatrix[0][2].xyz);
            @(if (mdlopt "n") [result [
                @(if (mdlopt "e") [result [
                    camvec = objmat * camdir;
                ]])
                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                vec3 wnormal = objmat * onormal;
                vec3 wtangent = objmat * otangent;
                vec3 wbitangent = cross(wnormal, wtangent) * vtangent.w;
                world = mat3(wtangent, wbitangent, wnormal);
            ]] [result [
                nvec = objmat * onormal; 
                @(if (mdlopt "e") [result [
                    float invfresnel = dot(camdir, onormal);
                    rvec = objmat * (2.0*invfresnel*onormal - camdir);
                    rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;    
                ]])
            ]])
        }
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [skelanimfragdefs])
        @(if (mdlopt "n") [result [
            varying mat3 world; 
            @(if (mdlopt "e") [result [
                uniform vec4 envmapscale;
                varying vec3 camvec;
            ]])
        ]] [result [
            varying vec3 nvec;
            @(if (mdlopt "e") [result [
                varying vec3 rvec;
                varying float rmod;
            ]])
        ]])
        @(if (|| (mdlopt "s") (mdlopt "m")) [result [uniform vec4 maskscale;]])
        uniform sampler2D tex0;
        @(if (mdlopt "m") [result [uniform sampler2D tex1;]])
        @(if (mdlopt "e") [result [uniform samplerCube tex2;]])
        @(if (mdlopt "n") [result [uniform sampler2D tex3;]])
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);

            gl_FragData[0] = diffuse;

            @(if (mdlopt "m") [result [
                vec3 masks = texture2D(tex1, gl_TexCoord[0].xy).rgb;
            ]])

            @(if (mdlopt "n") [result [
                vec3 normal = texture2D(tex3, gl_TexCoord[0].xy).rgb - 0.5;
                normal = normalize(world * normal);
            ]] [result [
                vec3 normal = normalize(nvec);
            ]])

            gl_FragData[1].rgb = 0.5*normal+0.5;

            @(if (mdlopt "s") [result [
                float spec = maskscale.x;
                @(if (mdlopt "m") [result [spec *= masks.r;]])   // specmap in red channel
                gl_FragData[1].a = 0.5*spec;
            ]] [result [
                gl_FragData[1].a = 0.0;
            ]])

            @(if (mdlopt "m") [result [
                gl_FragData[2] = vec4(diffuse.rgb*maskscale.y*masks.g, masks.g); // glow mask in green channel
                @(if (mdlopt "e") [result [
                    @(if (mdlopt "n") [result [
                        vec3 camn = normalize(camvec);
                        float invfresnel = dot(camn, normal);
                        vec3 rvec = 2.0*invfresnel*normal - camn;
                        float rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;
                    ]])
                    vec3 reflect = textureCube(tex2, rvec).rgb; 
                    rmod *= masks.b; // envmap mask in blue channel
                    gl_FragData[2] += vec4(reflect*rmod, rmod);
                ]])
            ]] [result [
                gl_FragData[2] = vec4(0.0);
            ]])
        }
    ]
]

modelanimshader = [
    fraganimshader = (? (> $arg2 0) $arg2)
    reuseanimshader = $fraganimshader
    if $ati_ubo_bug [
        reuseanimshader = (format "%1 , %2" $arg2 (> $arg2 0))
        if (= $arg4 1) [
            fraganimshader = (modelfragmentshader (concatword "bB" $arg3))
        ] [
            fraganimshader = $reuseanimshader
        ]
    ]
    variantshader 0 $arg1 $arg2 (modelvertexshader (concatword "B" $arg3) $arg4) $fraganimshader
    variantshader 0 $arg1 (+ $arg2 1) (modelvertexshader (concatword "b" $arg3) $arg4) $reuseanimshader
]
    
modelshader = [
    defershader 0 $arg1 [
        basemodeltype = [@@arg2]
        shader 0 @arg1 (modelvertexshader $basemodeltype) (modelfragmentshader $basemodeltype)
        loop i 4 [
            modelanimshader @@arg1 0 $basemodeltype (+ $i 1)
        ]
    ]
]

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

modelshader "nospecmodel" ""
modelshader "masksnospecmodel" "m"
modelshader "envmapnospecmodel" "me"
altshader envmapnospecmodel masksnospecmodel

modelshader "bumpnospecmodel" "n"
modelshader "bumpmasksnospecmodel" "nm"
modelshader "bumpenvmapnospecmodel" "nme"
altshader bumpenvmapnospecmodel bumpmasksnospecmodel

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

modelshader "stdmodel" "s"
fastshader stdmodel nospecmodel 1
modelshader "masksmodel" "sm"
fastshader masksmodel masksnospecmodel 1
modelshader "envmapmodel" "sme"
altshader envmapmodel masksmodel
fastshader envmapmodel envmapnospecmodel 1

modelshader "bumpmodel" "ns"
fastshader bumpmodel bumpnospecmodel 1
modelshader "bumpmasksmodel" "nsm"
fastshader bumpmasksmodel bumpmasksnospecmodel 1
modelshader "bumpenvmapmodel" "nsme"
altshader bumpenvmapmodel bumpmasksmodel
fastshader bumpenvmapmodel bumpenvmapnospecmodel 1

////////////////////////////////////////////////
//
// deferred shading
//
////////////////////////////////////////////////

shader 0 shadowmapworld [
    void main(void)
    {
        gl_Position = ftransform();
    }
] [
    void main(void)
    {
    }
]

shader 0 tetraworld [
    uniform vec4 tetraclip;
    void main(void)
    {
        gl_Position = ftransform();
        gl_ClipDistance[0] = dot(gl_Vertex, tetraclip); 
    }
] [
    void main(void)
    {
    }
]

deferredlightshader = [
    numlights = $arg1
    useao = $arg2
    variantshader 0 (? $useao "deferredlightao" "deferredlight") (? (> $numlights 0) 0 -1) [
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0, tex1, tex2, tex3;
        @(loopconcat j $numlights [result [
            uniform vec4 light@[j]pos;
            uniform vec3 light@[j]color;
        ]])
        uniform vec3 camera;
        uniform vec4 colorscale, lightscale;
        @(? $useao [uniform sampler2DRect tex5; uniform vec2 aoscale;])
        void main(void)
        {
            vec4 diffuse = texture2DRect(tex0, gl_FragCoord.xy) * colorscale;
            vec4 glow = texture2DRect(tex2, gl_FragCoord.xy);
            @(if $useao [result [
                float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                vec3 light = diffuse.rgb * lightscale.rgb * ao;
            ]] [result [
                vec3 light = diffuse.rgb * lightscale.rgb;
            ]])
            @(if (> $numlights 0) [result [
                vec4 normal = texture2DRect(tex1, gl_FragCoord.xy);
                float depth = texture2DRect(tex3, gl_FragCoord.xy).x;
                vec4 pos = gl_TextureMatrix[0] * vec4(gl_FragCoord.xy, depth, 1.0);
                pos.xyz /= pos.w;
                normal.xyz = normal.xyz*2.0 - 1.0;
                vec3 camdir = normalize(camera - pos.xyz);
            ]])
            @(loopconcat j $numlights [result [
                vec3 light@[j]dir = (light@[j]pos.xyz - pos.xyz) * light@[j]pos.w;
                float light@[j]dist2 = dot(light@[j]dir, light@[j]dir);
                if(light@[j]dist2 < 1.0)
                {
                    float light@[j]invdist = inversesqrt(light@[j]dist2); 
                    float light@[j]atten = 1.0 - light@[j]dist2 * light@[j]invdist;
                    light@[j]dir *= light@[j]invdist;
                    light@[j]atten *= max(dot(light@[j]dir, normal.xyz), 0.0);
                    float light@[j]spec = pow(max(dot(normalize(camdir + light@[j]dir), normal.xyz), 0.0), 32.0) * normal.a;
                    light += (diffuse.rgb + light@[j]spec) * light@[j]color * light@[j]atten;
                }
            ]])
            gl_FragColor.rgb = light * (1.0 - glow.a) + glow.rgb * lightscale.a;
            gl_FragColor.a = diffuse.a;
        }
    ]
]

deferredshadowshader = [
    numlights = $arg1
    shadowtetra = $arg2
    gatherpcf = $arg3 
    useao = $arg4
    variantshader 0 (? $useao "deferredshadowao" "deferredshadow") (? (> $numlights 0) (+ (? $shadowtetra 1 0) (? $gatherpcf 2 0)) -1) [
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        @(if $gatherpcf [result [
            #ifdef GL_EXT_gpu_shader4
            #  extension GL_EXT_gpu_shader4 : enable
            #endif
            #ifdef GL_ARB_texture_gather
            #  extension GL_ARB_texture_gather : enable
            #else
            #  ifdef GL_AMD_texture_texture4
            #    extension GL_AMD_texture_texture4 : enable
            #  endif
            #endif
        ]])
        uniform sampler2DRect tex0, tex1, tex2, tex3;
        uniform @(? $gatherpcf "sampler2D" "sampler2DShadow") tex4;
        @(loopconcat j $numlights [result [
            uniform vec4 light@[j]pos;
            uniform vec3 light@[j]color;
            uniform vec4 shadow@[j]params;
            uniform vec2 shadow@[j]offset;
        ]])
        uniform vec3 camera;
        uniform vec2 shadowatlasscale;
        uniform vec4 colorscale, lightscale;
        @(? $useao [uniform sampler2DRect tex5; uniform vec2 aoscale;])

        @(if $shadowtetra [result [
            vec3 getshadowtc(vec3 dir, vec4 shadowparams, vec2 shadowoffset)
            {
                float top = abs(dir.x+dir.y)+dir.z, bottom = abs(dir.x-dir.y)-dir.z;
                vec2 mparams = shadowparams.xy / max(top, bottom);
                shadowoffset.x += step(top, bottom)*shadowparams.z;
                return vec3(dir.xy*mparams.x + shadowoffset, mparams.y + shadowparams.w);
            }
        ]] [result [
            vec3 getshadowtc(vec3 dir, vec4 shadowparams, vec2 shadowoffset)
            {
                vec3 adir = abs(dir);
                float m; vec4 proj;
                if (adir.x > adir.y) { m = adir.x; proj = vec4(dir.zyx, 0.0); } else { m = adir.y; proj = vec4(dir.xzy, 1.0); }
                if (adir.z > m) { m = adir.z; proj = vec4(dir, 2.0); }
                vec2 mparams = shadowparams.xy / m;
                return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
            }
        ]])

        @(if $gatherpcf [result [
            #ifdef GL_ARB_texture_gather
            #  define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, ivec2(xoff, yoff))
            #else
            #  define shadowgather(center, xoff, yoff) texture4(tex4, center + vec2(xoff, yoff)*shadowatlasscale)
            #endif
            float filtershadow(vec3 shadowtc)
            {
                vec2 offset = fract(shadowtc.xy - 0.5), center = (shadowtc.xy - offset)*shadowatlasscale;
                vec4 group1 = step(shadowtc.z, shadowgather(center, -1.0, -1.0));
                vec4 group2 = step(shadowtc.z, shadowgather(center,  1.0, -1.0));
                vec4 group3 = step(shadowtc.z, shadowgather(center, -1.0,  1.0));
                vec4 group4 = step(shadowtc.z, shadowgather(center,  1.0,  1.0));
                vec4 cols = vec4(group1.rg, group2.rg) + vec4(group3.ab, group4.ab) + mix(vec4(group1.ab, group2.ab), vec4(group3.rg, group4.rg), offset.y);
                return dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));
            }
        ]] [result [
            #define shadowval(center, xoff, yoff) shadow2D(tex4, vec3((center.xy + vec2(xoff, yoff))*shadowatlasscale, center.z)).r
            float filtershadow(vec3 shadowtc)
            {
                return dot(vec4(0.25),
                            vec4(shadowval(shadowtc, -0.4, 1.0), 
                                shadowval(shadowtc, -1.0, -0.4),
                                shadowval(shadowtc, 0.4, -1.0), 
                                shadowval(shadowtc, 1.0, 0.4))); 
            }
        ]])

        void main(void)
        {
            vec4 diffuse = texture2DRect(tex0, gl_FragCoord.xy) * colorscale;
            vec4 glow = texture2DRect(tex2, gl_FragCoord.xy);
            @(if $useao [result [
                float ao = texture2DRect(tex5, gl_FragCoord.xy*aoscale).r;
                vec3 light = diffuse.rgb * lightscale.rgb * ao;
            ]] [result [
                vec3 light = diffuse.rgb * lightscale.rgb;
            ]])
            @(if (> $numlights 0) [result [
                vec4 normal = texture2DRect(tex1, gl_FragCoord.xy);
                float depth = texture2DRect(tex3, gl_FragCoord.xy).x;
                vec4 pos = gl_TextureMatrix[0] * vec4(gl_FragCoord.xy, depth, 1.0);
                pos.xyz /= pos.w;
                normal.xyz = normal.xyz*2.0 - 1.0;
                vec3 camdir = normalize(camera - pos.xyz);
            ]])
            @(loopconcat j $numlights [result [
                vec3 light@[j]dir = (pos.xyz - light@[j]pos.xyz) * light@[j]pos.w;
                float light@[j]dist2 = dot(light@[j]dir, light@[j]dir);
                if(light@[j]dist2 < 1.0)
                {
                    vec3 shadow@[j]tc = getshadowtc(light@[j]dir, shadow@[j]params, shadow@[j]offset);
                    float shadow@[j]val = filtershadow(shadow@[j]tc);
                    float light@[j]invdist = inversesqrt(light@[j]dist2); 
                    float light@[j]atten = 1.0 - light@[j]dist2 * light@[j]invdist;
                    light@[j]dir *= -light@[j]invdist;
                    light@[j]atten *= max(dot(light@[j]dir, normal.xyz), 0.0) * shadow@[j]val;
                    float light@[j]spec = pow(max(dot(normalize(camdir + light@[j]dir), normal.xyz), 0.0), 32.0) * normal.a;
                    light += (diffuse.rgb + light@[j]spec) * light@[j]color * light@[j]atten;
                }
            ]])
            gl_FragColor.rgb = light * (1.0 - glow.a) + glow.rgb * lightscale.a;
            gl_FragColor.a = diffuse.a;
        }
    ]
]

loop i (+ 1 7) [
    loop j 2 [
        deferredlightshader $i $j
        loop k 2 [
            deferredshadowshader $i $k 0 $j
            if (&& $i $usetexgather) [
                deferredshadowshader $i $k 1 $j
            ]
        ]
    ]
]

deferredcsmshader = [
    numsplits = $arg1
    gatherpcf = $arg2
    lastsplit = (- $numsplits 1)
    variantshader 0 "deferredcsm" (? (> $numsplits 0) ($gatherpcf 1 0) -1) [
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        @(loopconcat j $numsplits [result [
            uniform float split@[j]far;
        ]])
        uniform sampler2DRect tex0, tex1, tex2, tex3;
        uniform sampler2DShadow tex4;
        uniform vec3 camera;
        uniform vec3 cameraview;

        @(if (> $numsplits 0) [result [
            vec3 getshadowtc(vec4 pos, float z)
            {
                int index = 1 + @[lastsplit];
                if (0 == 1) {}
                @(loopconcat j (- $numsplits 1) [result [
                else if(z < split@[j]far)
                    index = @[j] + 1;
                ]])
                vec4 shadow_coord = gl_TextureMatrix[index]*pos;
                shadow_coord.xyz /= shadow_coord.w;
#if 0
                if (index == 1)
                    shadow_coord = vec4(1,0,0,1);
                else if (index == 2)
                    shadow_coord = vec4(0,1,0,1);
                else if (index == 3)
                    shadow_coord = vec4(0,0,1,1);
                else
                    shadow_coord = vec4(0.);
#elif 0
                float t = shadow_coord.x;
                if (t < 1024. / 4096.)
                    shadow_coord = vec4(1,0,0,1);
                else if (t < 2048. / 4096.)
                    shadow_coord = vec4(0,1,0,1);
                else if (t < (2048.+1024.) / 4096.)
                    shadow_coord = vec4(0,0,1,1);
                else
                    shadow_coord = vec4(0.);
#endif
                return shadow_coord.xyz;
            }
        ]])

        void main(void)
        {
            vec4 diffuse = texture2DRect(tex0, gl_FragCoord.xy);
            vec4 glow = texture2DRect(tex2, gl_FragCoord.xy);
            vec4 normal = texture2DRect(tex1, gl_FragCoord.xy);
            float depth = texture2DRect(tex3, gl_FragCoord.xy).x;
            vec4 pos = gl_TextureMatrix[0] * vec4(gl_FragCoord.xy, depth, 1.0);
            pos.xyzw /= pos.w;
            normal.xyz = normal.xyz*2.0 - 1.0;
            vec3 camdir = camera - pos.xyz;
            float z = -dot(cameraview, camdir);
            camdir = normalize(camdir);
            @(if (> $numsplits 0) [result [
            vec3 tc = getshadowtc(pos, z);
            gl_FragColor = diffuse * shadow2D(tex4, tc).rrrr;
            //gl_FragColor = diffuse*tc.xyzz;
            //gl_FragColor = abs(normal);//*tc.xyzz;
            //gl_FragColor = diffuse * tc.xyzz;
            ]] [result [
            gl_FragColor = vec4(1.f);
            ]])
        }
    ]
]

loop i 7 [
    loop j 2 [
        deferredcsmshader $i $j
    ]
]

shader 0 "hdrreduce" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        gl_FragColor.rgb = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
    }
]

shader 0 "hdrreduce2" [
    uniform vec2 reducestep;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, -1.0)*reducestep;
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, -1.0)*reducestep;
        tap2 = gl_MultiTexCoord0.xy + vec2( 1.0,  1.0)*reducestep;
        tap3 = gl_MultiTexCoord0.xy + vec2(-1.0,  1.0)*reducestep;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_FragColor.rgb = 0.25*(texture2DRect(tex0, tap0).rgb + texture2DRect(tex0, tap1).rgb +
                                 texture2DRect(tex0, tap2).rgb + texture2DRect(tex0, tap3).rgb);
    }
]

//lumweights = "0.2126, 0.7152, 0.0722"
lumweights = "0.299, 0.587, 0.114"

shader 0 "hdrluminance" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        float lum = dot(color, 4.0*vec3(@lumweights));
        float loglum = (log2(lum + 1.0/255.0) + 8.0) * (1.0/(8.0+2.0));// allow values as low as 2^-8, and as high 2^2, with 2^-8ish epsilon
        gl_FragColor.rgb = vec3(loglum);
    }
]

shader 0 "hdrluminance2" [
    uniform vec2 reducestep;
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        gl_Position = gl_Vertex;
        tap0 = gl_MultiTexCoord0.xy + vec2(-1.0, -1.0)*reducestep;
        tap1 = gl_MultiTexCoord0.xy + vec2( 1.0, -1.0)*reducestep;
        tap2 = gl_MultiTexCoord0.xy + vec2( 1.0,  1.0)*reducestep;
        tap3 = gl_MultiTexCoord0.xy + vec2(-1.0,  1.0)*reducestep;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    varying vec2 tap0, tap1, tap2, tap3;
    void main(void)
    {
        @(loopconcat i 4 [result [
            vec3 color@[i] = texture2DRect(tex0, tap@[i]).rgb;
            float lum@[i] = dot(color@[i], 4.0*vec3(@lumweights));
            float loglum@[i] = (log2(lum@[i] + 1.0/255.0) + 8.0) * (1.0/(8.0+2.0));// allow values as low as 2^-8, and as high 2^2, with 2^-8ish epsilon
        ]])
        gl_FragColor.rgb = vec3(0.25*(loglum0 + loglum1 + loglum2 + loglum3));
    }
]

shader 0 "hdraccum" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    uniform float accumscale;
    void main(void)
    {
        float lum = exp2((texture2DRect(tex0, gl_TexCoord[0].xy).r * (8.0+2.0)) - 8.0) - 1.0/255.0;
        gl_FragColor = vec4(vec3(lum*0.25), accumscale);
    }
]

shader 0 "hdrbloom" [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex2; 
    uniform vec4 bloomparams;
    varying float lumscale;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        float avglum = 4.0*texture2DRect(tex2, vec2(0.5, 0.5)).r;
        lumscale = bloomparams.x/clamp(avglum, bloomparams.z, bloomparams.w);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    uniform vec4 bloomparams;
    varying float lumscale;
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb*4.0;
        float lum = dot(color, vec3(@lumweights));
        color *= (1.0 - exp2(min(lum*lumscale + bloomparams.y, 0.0))) / (lum + 1.0e-4);
        gl_FragColor.rgb = color;
    }
]

shader 0 "hdrtonemap" [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex2; 
    uniform vec4 hdrparams;
    uniform vec2 bloomsize;
    varying float lumscale;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        gl_TexCoord[1].xy = (gl_Vertex.xy*0.5 + 0.5)*bloomsize;
        float avglum = 4.0*texture2DRect(tex2, vec2(0.5, 0.5)).r;
        lumscale = hdrparams.x/avglum;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0, tex1;
    uniform vec4 hdrparams;
    varying float lumscale;
    void main(void)
    {
        vec3 color = texture2DRect(tex0, gl_TexCoord[0].xy).rgb*4.0;
        vec3 bloom = texture2DRect(tex1, gl_TexCoord[1].xy).rgb*hdrparams.y;

        //color = clamp(pow(color/(color + avg*hdrparams.x), 2.2), hdrparams.z*color, hdrparams.w*color);

        //float lumscale = dot(avg, vec3(@lumweights)), lum = dot(color, vec3(@lumweights));
        //float l = 0.18*lum/(lumscale*hdrparams.x);
        //color *= l * (1.0 + l / (2 * 2)) / (l + 1) / lum;
//        float lumscale = dot(avg, vec3(@lumweights)), lum = dot(color, vec3(@lumweights));
//        color *= (1.0 + 0.18*lum/(lumscale*hdrparams.x)/(4*4)) / (lum + lumscale*hdrparams.x/0.18);
        //(1.0 + lum*(1/(x*k))) / (lum + x)
        //color *= 0.18/(avg*hdrparams.x);
        //color = color / (color + 1.0);

        //color = pow(color, 2.2) * 0.18/pow(avg*hdrparams.x, 2.2);
        //color = pow(color, 1.0) * 0.18 / pow(avg*hdrparams.x, 1.0);

//        color = pow(color*0.18/(avg*hdrparams.x), 2.2);
//        color = pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06), 1.0);

        //float l = lum;
        //l = pow(l*0.18/(lumscale*hdrparams.x), 1.0);
        //l = pow((l*(6.2*l+0.5))/(l*(6.2*l+1.7)+0.06), 2.2);
        //color *= l/lum;

//        color *= 0.18/(avg*hdrparams.x);
//        color = max(0.0, color-0.004);
//        color = (color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06);
//        color = pow(color, 2.2);

#define F(x,A,B,C,D,E,F) ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F)-E/F)
        //vec3 foo = avg*hdrparams.x/0.18;
       
//        color = 1.0 - exp2(color*lumscale);
        float lum = dot(color, vec3(@lumweights));       
        color *= clamp((1.0 - exp2(lum*lumscale)) / (lum + 1.0e-4), hdrparams.z, hdrparams.w);

   //     color *= 0.36/(lumscale*hdrparams.x);
        //color = color * (1.0 + color/(4.0*4.0)) / (color + 1.0);
 //       color *= 2.0*0.18/(lumscale*hdrparams.x);
 //       float white = 11.2;
 //       color = F(color, 0.22, 0.30, 0.10, 0.20, 0.01, 0.30) / F(white, 0.22, 0.30, 0.10, 0.20, 0.01, 0.30);
        gl_FragColor.rgb = color + bloom;
    }
]

aotapoffsets = [
"-0.933103, 0.025116"
"-0.432784, -0.989868"
"0.432416, -0.413800"
"-0.117770, 0.970336"
"0.837276, 0.531114"
"-0.184912, 0.200232"
"-0.955748, 0.815118"
"0.946166, -0.998596"
"-0.897519, -0.581102"
"0.979248, -0.046602"
"-0.155736, -0.488204"
"0.460310, 0.982178"
]

ambientobscuranceshader = [
    maxaotaps = $arg1 
    lineardepth = $arg2
    variantshader 0 "ambientobscurance" (? $lineardepth 1 (? (> $maxaotaps 1) 0 -1)) [
        uniform vec2 noisescale;
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            gl_TexCoord[1].xy = gl_Vertex.xy*noisescale;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0, tex1;
        uniform sampler2D tex2;
        uniform vec4 aoparams, offsetscale;
        @(? $lineardepth [
            #define depthtc gl_FragCoord.xy
        ] [
            #define depthtc gl_TexCoord[0].xy
            uniform vec4 depthscale;
        ])
        void main(void)
        {
            float depth = texture2DRect(tex0, depthtc).r;
            vec3 normal = texture2DRect(tex1, gl_TexCoord[0].xy).rgb*2.0 - 1.0;
            normal = mat3(gl_ModelViewMatrix[0].xyz, gl_ModelViewMatrix[1].xyz, gl_ModelViewMatrix[2].xyz) * normal;
            @(? $lineardepth [
                vec2 tapscale = aoparams.xy/depth;
            ] [
                float w = depth*depthscale.y + depthscale.z;
                depth = depthscale.x / w;
                vec2 tapscale = aoparams.xy*w;
            ])
            vec2 pos = depth*(depthtc*offsetscale.xy + offsetscale.zw);
            vec2 noise = texture2D(tex2, gl_TexCoord[1].xy).rg*2.0-1.0;
            float obscure = 0.0;
            @(loopconcat i $maxaotaps [result [
                vec2 offset@[i] = reflect(vec2(@(at $aotapoffsets $i)), noise);
                offset@[i] = depthtc + tapscale * offset@[i];
                @(? $lineardepth [
                    float depth@[i] = texture2DRect(tex0, offset@[i].xy).r;
                ] [
                    float depth@[i] = depthscale.x / (texture2DRect(tex0, offset@[i].xy).r*depthscale.y + depthscale.z);
                ])
                vec3 v@[i] = vec3(depth@[i]*(offset@[i].xy*offsetscale.xy + offsetscale.zw) - pos, depth@[i] - depth);
                obscure += max(0.0, dot(v@[i], normal) + depth*1.0e-2) / (dot(v@[i], v@[i]) + 1.0e-5);
            ]])
            gl_FragColor.rg = vec2(pow(max(1.0 - aoparams.z*obscure, 0.0), aoparams.w), depth);
        }
    ]
]

loop i (- 12 1) [
    ambientobscuranceshader (+ 1 $i) 0
    ambientobscuranceshader (+ 1 $i) 1
]

shader 0 "linearizedepth" [
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    uniform vec4 depthscale;
    void main(void)
    {
        float depth = texture2DRect(tex0, gl_TexCoord[0].xy).r;
        gl_FragColor.r = depthscale.x / (depth*depthscale.y + depthscale.z);
    }
] 

linearbilateralshader = [
    numtaps = $arg2
    filterdir = $arg3
    variantshader 0 $arg1 0 [
        uniform vec4 offsets;
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0, tex1;
        uniform vec4 bilateralparams;
        @(? (=s $filterdir "x") [#define tapoffset(i) vec2(i, 0.0)] [#define tapoffset(i) vec2(0.0, i)])
        void main(void)
        {
            vec2 tc = gl_FragCoord.xy;
            float depth = texture2DRect(tex1, tc).r;
            float color = texture2DRect(tex0, tc).r;
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                result [
                    vec2 tc@[i] = gl_FragCoord.xy + tapoffset(@(+f $curtap));
                    float depth@[i] = texture2DRect(tex1, tc@[i]).r - depth;
                    float color@[i] = texture2DRect(tex0, tc@[i]).r;
                    float weight@[i] = exp(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            gl_FragColor.rgb = vec3(color / weights);
        }
    ]
]

bilateralshader = [
    numtaps = $arg2
    filterdir = $arg3
    variantshader 0 $arg1 -1 [
        uniform vec4 offsets;
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0, tex1;
        uniform vec4 bilateralparams;
        @(? (=s $filterdir "x") [#define tapoffset(i) vec2(i, 0.0)] [#define tapoffset(i) vec2(0.0, i)])
        uniform vec4 depthscale;
        void main(void)
        {
            float depth = texture2DRect(tex1, gl_TexCoord[0].xy).r;
            float color = texture2DRect(tex0, gl_FragCoord.xy).r;
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                result [
                    float depth@[i] = texture2DRect(tex1, gl_TexCoord[0].xy + tapoffset(@(+f $curtap))).r - depth;
                    float color@[i] = texture2DRect(tex0, gl_FragCoord.xy + tapoffset(@(+f $curtap))).r;
                    float weight@[i] = exp(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            gl_FragColor.rgb = vec3(color / weights);
        }
    ]
]

packedbilateralshader = [
    numtaps = $arg2
    filterdir = $arg3
    variantshader 0 $arg1 1 [
        uniform vec4 offsets;
        void main(void)
        {
            gl_Position = gl_Vertex;
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0;
        uniform vec4 bilateralparams;
        @(? (=s $filterdir "x") [#define tapoffset(i) vec2(i, 0.0)] [#define tapoffset(i) vec2(0.0, i)])
        void main(void)
        {
            vec2 vals = texture2DRect(tex0, gl_FragCoord.xy).rg;
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                result [
                    vec2 vals@[i] = texture2DRect(tex0, gl_FragCoord.xy + tapoffset(@(+f $curtap))).rg;
                    float depth@[i] = vals@[i].y - vals.y;
                    float weight@[i] = exp(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    vals.x += weight@[i] * vals@[i].x;
                ]
            ])
            gl_FragColor.rg = vec2(vals.x / weights, vals.y);
        }
    ]
]
 
loop i 10 [
    bilateralshader (format "bilateralx%1" (+ $i 1)) (+ $i 1) x 
    bilateralshader (format "bilateraly%1" (+ $i 1)) (+ $i 1) y
    linearbilateralshader (format "bilateralx%1" (+ $i 1)) (+ $i 1) x
    linearbilateralshader (format "bilateraly%1" (+ $i 1)) (+ $i 1) y
    packedbilateralshader (format "bilateralx%1" (+ $i 1)) (+ $i 1) x
    packedbilateralshader (format "bilateraly%1" (+ $i 1)) (+ $i 1) y
    if (> $i 0) [
        altshader (format "bilateralx%1" (+ $i 1)) (format "bilateralx%1" $i)
        altshader (format "bilateraly%1" (+ $i 1)) (format "bilateraly%1" $i)
    ]
    
]

////////////////////////////////////////////////
//
// buffer splitting / merging
//
////////////////////////////////////////////////

shader 0 "buffersplit" [ 
    void main(void)
    {
        gl_Position = gl_Vertex;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex;
    uniform vec2 rcptiledim;
    uniform vec2 tiledim;
    uniform vec2 split;
    void main(void)
    {
        vec2 tile = gl_FragCoord.xy * rcptiledim;
        vec2 block = gl_FragCoord.xy - tiledim * floor(gl_FragCoord.xy * rcptiledim);
        vec2 coord = tile + block * split;
        gl_FragColor.rgb = texture2DRect(tex, coord).rgb;
    }
]

shader 0 "buffermerge" [
    void main(void)
    {
        gl_Position = gl_Vertex;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex;
    uniform vec2 tiledim;
    uniform vec2 split;
    uniform vec2 rcpsplit;
    void main(void)
    {
        vec2 block = gl_FragCoord.xy * rcpsplit;
        vec2 tile = gl_FragCoord.xy - split * floor(gl_FragCoord.xy * rcpsplit);
        vec2 coord = tile * tiledim + block;
        gl_FragColor.rgb = texture2DRect(tex, coord).rgb;
    }
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        uniform vec4 offsets;
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            vec2 tc1 = gl_MultiTexCoord0.xy + offsets.xy;
            vec2 tc2 = gl_MultiTexCoord0.xy - offsets.xy;
            gl_TexCoord[1].xy = tc1;
            gl_TexCoord[2].xy = tc2;
            @(loopconcat i (min (- $arg2 1) 2) [concatword [
                tc1.@@arg3 += offsets.@(at "z w" $i);
                tc2.@@arg3 -= offsets.@(at "z w" $i);
                gl_TexCoord[@@(+ (* $i 2) 3)].xy = tc1;
                gl_TexCoord[@@(+ (* $i 2) 4)].xy = tc2;
            ]])
        } 
    ] [
        @(if (=s $arg4 "2DRect") [result [
            #extension GL_ARB_texture_rectangle : enable
        ]])
        uniform vec4 weights, weights2, offset4, offset5, offset6, offset7;
        uniform @(concatword "sampler" $arg4) tex0;
        void main(void)
        {
            #define texval(coords) @(concatword "texture" $arg4)(tex0, (coords))
            vec4 val = texval(gl_TexCoord[0].xy) * weights.x;
            @(loopconcat i $arg2 [concatword [
                @(if (< $i 3) [result [
                    val += weights.@(at "y z w" $i) * (texval(gl_TexCoord[@@(+ (* $i 2) 1)].xy) + texval(gl_TexCoord[@@(+ (* $i 2) 2)].xy));
                ]] [result [
                    val += weights2.@(at "x y z w" (- $i 3)) * 
                                (texval(gl_TexCoord[0].xy + @(at "offset4 offset5 offset6 offset7" (- $i 3)).xy) +
                                 texval(gl_TexCoord[0].xy - @(at "offset4 offset5 offset6 offset7" (- $i 3)).xy));
                ]])
            ]])
            gl_FragColor = val;
        }
    ]
]

loop i 7 [
    blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x 2D
    blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y 2D
    if (> $i 0) [
        altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
        altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
    ]
    if $usetexrect [
        blurshader (format "blurx%1rect" (+ $i 1)) (+ $i 1) x 2DRect
        blurshader (format "blury%1rect" (+ $i 1)) (+ $i 1) y 2DRect
        if (> $i 0) [
            altshader (format "blurx%1rect" (+ $i 1)) (format "blurx%1rect" $i)
            altshader (format "blury%1rect" (+ $i 1)) (format "blury%1rect" $i)
        ]
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [
    void main(void)
    {
        gl_Position = gl_Vertex;   // woohoo, no mvp :) 
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
]

fsps = [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        vec4 sample = texture2DRect(tex0, gl_TexCoord[0].xy);
]

setup4corners = [
    gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.5, -1.5);
    gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.5, -1.5);
    gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2(-1.5,  1.5);
    gl_TexCoord[4].xy = gl_MultiTexCoord0.xy + vec2( 1.5,  1.5);
]

sample4corners = [
    vec4 s00 = texture2DRect(tex0, gl_TexCoord[1].xy);
    vec4 s02 = texture2DRect(tex0, gl_TexCoord[2].xy);
    vec4 s20 = texture2DRect(tex0, gl_TexCoord[3].xy);
    vec4 s22 = texture2DRect(tex0, gl_TexCoord[4].xy);
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" [ @fsvs } ] [ @fsps gl_FragColor = 1.0 - sample; } ]
lazyshader 0 "gbr"    [ @fsvs } ] [ @fsps gl_FragColor = sample.yzxw; } ]
lazyshader 0 "bw"     [ @fsvs } ] [ @fsps gl_FragColor = vec4(dot(sample.xyz, vec3(0.333))); } ]

// sobel

lazyshader 0 "sobel" [ @fsvs @setup4corners } ] [
    @fsps
    @sample4corners

        vec4 t = s00 + s20 - s02 - s22;
        vec4 u = s00 + s02 - s20 - s22;
        gl_FragColor = sample + t*t + u*u;
    }
]

// rotoscope

lazyshader 0 "rotoscope" [
    uniform vec4 params;
    void main(void)
    {
        gl_Position = gl_Vertex;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;

        // stuff two sets of texture coordinates into each one to get around hardware attribute limits
        gl_TexCoord[1] = vec4(-1.0, -1.0,  1.0, 0.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[2] = vec4(-1.0,  0.0, -1.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[3] = vec4(-1.0,  1.0,  0.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
        gl_TexCoord[4] = vec4( 0.0, -1.0,  1.0, 1.0)*params.x + gl_MultiTexCoord0.xyyx;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0; 
    void main(void)
    {
        #define t11 gl_TexCoord[0]
        #define t00_12 gl_TexCoord[1]
        #define t01_20 gl_TexCoord[2]
        #define t02_21 gl_TexCoord[3]
        #define t10_22 gl_TexCoord[4]
        vec4 c00 = texture2DRect(tex0, t00_12.xy);
        vec4 c01 = texture2DRect(tex0, t01_20.xy);
        vec4 c02 = texture2DRect(tex0, t02_21.xy);
        vec4 c10 = texture2DRect(tex0, t10_22.xy);
        vec4 c11 = texture2DRect(tex0, t11.xy);
        vec4 c12 = texture2DRect(tex0, t00_12.wz);
        vec4 c20 = texture2DRect(tex0, t01_20.wz);
        vec4 c21 = texture2DRect(tex0, t02_21.wz);
        vec4 c22 = texture2DRect(tex0, t10_22.wz);

        vec4 diag1 = c00 - c22;
        vec4 diag2 = c02 - c20;
        vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
        vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
        xedge *= xedge;
        yedge *= yedge;

        vec4 xyedge = xedge + yedge;
        float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

        float hue = dot(c11.xyz, vec3(1.0));
        c11 /= hue;
        vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
        c11 *= dot(cc, vec3(0.5, 0.5, 1.5)); 
        
        gl_FragColor = c11 * max(cc.z, sobel);
        
    }
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0));
            gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0));
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0; 
        void main(void)
        {
            gl_FragColor = 0.5*(texture2DRect(tex0, gl_TexCoord[0].xy) + texture2DRect(tex0, gl_TexCoord[1].xy));
        }
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [ 
        @fsvs 
            gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2 -1.333 0.0), @(if $arg3 -1.333 0.0));
            gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2(@(if $arg2  1.333 0.0), @(if $arg3  1.333 0.0));
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform sampler2DRect tex0; 
        void main(void)
        {
            gl_FragColor = 0.4*texture2DRect(tex0, gl_TexCoord[0].xy) + 0.3*(texture2DRect(tex0, gl_TexCoord[1].xy) + texture2DRect(tex0, gl_TexCoord[2].xy));
        }
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

// bloom-ish

lazyshader 0 "bloom_scale" [ @fsvs @setup4corners } ] [
    @fsps
    @sample4corners
        gl_FragColor = 0.2 * (s02 + s00 + s22 + s20 + sample);
    }
]

lazyshader 0 "bloom_init" [ @fsvs } ] [
    @fsps
        float t = max(sample.r, max(sample.g, sample.b));
        gl_FragColor = t*t*sample;
    }
]

bloomshader = [
  defershader 0 $arg1 [
    forceshader "bloom_scale"
    forceshader "bloom_init"
    shader 0 @arg1 [
        void main(void)
        {
            gl_Position = gl_Vertex;
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            vec2 tc = gl_MultiTexCoord0.xy;
            @@(loopconcat i $arg2 [concat [
                tc *= 0.5;
                gl_TexCoord[@@(+ $i 1)].xy = tc;
            ]])
        }
    ] [
        #extension GL_ARB_texture_rectangle : enable
        uniform vec4 params;
        uniform sampler2DRect tex0 @@(loopconcat i $arg2 [format ", tex%1" (+ $i 1)]); 
        void main(void)
        {
            vec4 sample = texture2DRect(tex0, gl_TexCoord[0].xy);
            @@(loopconcat i $arg2 [
                format [
                    @(? (> $i 0) "bloom +=" "vec4 bloom =") texture2DRect(tex%1, gl_TexCoord[%1].xy);
                ] (+ $i 1)
            ])
            gl_FragColor = bloom*params.x + sample;
        }
    ]
  ]
]

bloomshader bloom1 1
bloomshader bloom2 2
bloomshader bloom3 3
bloomshader bloom4 4
bloomshader bloom5 5
bloomshader bloom6 6

setupbloom = [
    addpostfx bloom_init 1 1 "+0"
    loop i (- $arg1 1) [
        addpostfx bloom_scale (+ $i 2) (+ $i 2) (concatword "+" (+ $i 1))
    ]
    addpostfx (concatword bloom $arg1) 0 0 (loopconcat i (+ $arg1 1) [result $i]) $arg2
]

bloom = [
    clearpostfx
    if (>= $numargs 1) [setupbloom 6 $arg1]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform vec4 center, animstate;
        @(if (>= (strstr $arg1 "3d") 0) [result [uniform vec4 texgenS, texgenT;]])
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams, depthfxview;]]) 
        void main(void)
        {
            vec4 wobble = vec4(gl_Vertex.xyz*(1.0 + 0.5*abs(fract(dot(gl_Vertex.xyz, center.xyz) + animstate.w*0.002) - 0.5)), gl_Vertex.w);
            @(if (>= (strstr $arg1 "soft") 0) [result [
                vec4 projtc = gl_ModelViewProjectionMatrix * wobble;
                gl_Position = projtc;

                projtc.z = depthfxparams.y - (gl_ModelViewMatrix * wobble).z*depthfxparams.x;
                projtc.xy = (projtc.xy + projtc.w)*depthfxview.xy;
                gl_TexCoord[3] = projtc;
            ]] [result [
                gl_Position = gl_ModelViewProjectionMatrix * wobble;
            ]])

            gl_FrontColor = gl_Color;
        
            @arg2 
        } 
    ] [ 
        @(if (>= (strstr $arg1 "rect") 0) [result [
            #extension GL_ARB_texture_rectangle : enable
            uniform sampler2DRect tex2;
        ]] [result [
            uniform sampler2D tex2;
        ]])
        uniform sampler2D tex0, tex1;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams;]]) 
        @(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
        void main(void)
        {
            vec2 dtc = gl_TexCoord[0].xy + texture2D(tex0, @arg3.xy).xy*0.1; // use color texture as noise to distort texcoords
            vec4 diffuse = texture2D(tex0, dtc);
            vec4 blend = texture2D(tex1, gl_TexCoord[1].xy); // get blend factors from modulation texture 
            diffuse *= blend.a*4.0; // dup alpha into RGB channels + intensify and over saturate
            diffuse.b += 0.5 - blend.a*0.5; // blue tint 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                gl_FragColor.rgb = diffuse.rgb * gl_Color.rgb;

                #define depthvals @(format "texture%1Proj" (? (>= (strstr $arg1 "rect") 0) "2DRect" "2D"))(tex2, gl_TexCoord[3])
                @(if (>= (strstr $arg1 "soft8") 0) [result [
                    float depth = dot(depthvals, depthfxselect);
                ]] [result [
                    float depth = depthvals.x*depthfxparams.z;
                ]])
                gl_FragColor.a = diffuse.a * max(clamp(depth - gl_TexCoord[3].z, 0.0, 1.0) * gl_Color.a, depthfxparams.w);
            ]] [result [
                gl_FragColor = diffuse * gl_Color;
            ]])
        }
    ]
]

loop i (if $usetexrect 5 3) [
    explosionshader (concatword "explosion2d" (at ["" "soft" "soft8" "softrect" "soft8rect"] $i)) [
        //blow up the tex coords
        float dtc = 1.768 - animstate.x*1.414; // -2, 2.5; -> -2*sqrt(0.5), 2.5*sqrt(0.5);
        dtc *= dtc;
        gl_TexCoord[0].xy = animstate.w*0.0004 + dtc*gl_Vertex.xy;
        gl_TexCoord[1].xy = gl_Vertex.xy*0.5 + 0.5; //using wobble makes it look too spherical at a distance
    ] "gl_TexCoord[1]"
    explosionshader (concatword "explosion3d" (at ["" "soft" "soft8" "softrect" "soft8rect"] $i)) [
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        vec2 texgen = vec2(dot(texgenS, gl_Vertex), dot(texgenT, gl_Vertex)); 
        gl_TexCoord[1].xy = texgen;
        gl_TexCoord[2].xy = texgen - animstate.w*0.0005;
    ] "gl_TexCoord[2]"
]

shader 0 "particlenotexture" [
    #pragma CUBE2_fog
    uniform vec4 colorscale;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0] = gl_Color * colorscale;
    } 
] [
    void main(void)
    {
        gl_FragColor = gl_TexCoord[0];
    }
]

particleshader = [
    shader 0 $arg1 [
        #pragma CUBE2_fog
        uniform vec4 colorscale;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams, depthfxview;]]) 
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
            gl_TexCoord[1] = gl_Color * colorscale; 

            @(if (>= (strstr $arg1 "soft") 0) [result [
                vec4 projtc = gl_ModelViewProjectionMatrix * gl_Vertex;
                projtc.xy = (projtc.xy + projtc.w) * depthfxview.xy;
                gl_TexCoord[2] = projtc;

                vec2 offset = gl_MultiTexCoord0.xy*2.82842712474619 - 1.4142135623731;
                gl_TexCoord[3].xyz = vec3(offset, 1.0);
                gl_TexCoord[4].xyz = vec3(offset, depthfxparams.y - (gl_ModelViewMatrix * gl_Vertex).z*depthfxparams.x);
            ]])
        }
    ] [
        @(if (>= (strstr $arg1 "soft") 0) [
            if (>= (strstr $arg1 "rect") 0) [result [
                #extension GL_ARB_texture_rectangle : enable
                uniform sampler2DRect tex2;
            ]] [result [
                uniform sampler2D tex2;
            ]]
        ])
        uniform sampler2D tex0;
        @(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams;]]) 
        @(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);

            @(if (>= (strstr $arg1 "soft") 0) [result [
                #define depthvals @(format "texture%1Proj" (? (>= (strstr $arg1 "rect") 0) "2DRect" "2D"))(tex2, gl_TexCoord[2])
                @(if (>= (strstr $arg1 "soft8") 0) [result [
                    float depth = dot(depthvals, depthfxselect);
                ]] [result [
                    float depth = depthvals.x*depthfxparams.z;
                ]])
                diffuse.a *= clamp(depth - dot(gl_TexCoord[3].xyz, gl_TexCoord[4].xyz), 0.0, 1.0);
            ]])

            gl_FragColor = diffuse * gl_TexCoord[1];
        }
    ]     
]

loop i (if $usetexrect 5 3) [
    particleshader (concatword "particle" (at ["" "soft" "soft8" "softrect" "soft8rect"] $i))
]

shader 0 "blendbrush" [
    uniform vec4 texgenS, texgenT;
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = vec2(dot(texgenS, gl_Vertex), dot(texgenT, gl_Vertex));
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = texture2D(tex0, gl_TexCoord[0].xy) * gl_Color;
    }
]

lazyshader 0 "moviergb" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        gl_FragColor = texture2DRect(tex0, gl_TexCoord[0].xy);
    }
]

lazyshader 0 "movieyuv" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        gl_FragColor = vec4(dot(sample, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample, vec3(-0.148224, -0.290992, 0.439216)) + 0.501961,
                            dot(sample, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            0.0);
    }
]

lazyshader 0 "moviey" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-1.5, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-0.5, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 0.5, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 1.5, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample2, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample1, vec3(0.256788, 0.504125, 0.097905)) + 0.062745,
                            dot(sample4, vec3(0.256788, 0.504125, 0.097905)) + 0.062745);
    }
]

lazyshader 0 "movieu" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample2, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample1, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961,
                            dot(sample4, vec3(-0.148224, -0.290992, 0.43921)) + 0.501961);
    }
]

lazyshader 0 "moviev" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy + vec2(-3.0, 0.0);
        gl_TexCoord[1].xy = gl_MultiTexCoord0.xy + vec2(-1.0, 0.0);
        gl_TexCoord[2].xy = gl_MultiTexCoord0.xy + vec2( 1.0, 0.0);
        gl_TexCoord[3].xy = gl_MultiTexCoord0.xy + vec2( 3.0, 0.0);
    }
] [
    #extension GL_ARB_texture_rectangle : enable
    uniform sampler2DRect tex0;
    void main(void)
    {
        vec3 sample1 = texture2DRect(tex0, gl_TexCoord[0].xy).rgb;
        vec3 sample2 = texture2DRect(tex0, gl_TexCoord[1].xy).rgb;
        vec3 sample3 = texture2DRect(tex0, gl_TexCoord[2].xy).rgb;
        vec3 sample4 = texture2DRect(tex0, gl_TexCoord[3].xy).rgb;
        gl_FragColor = vec4(dot(sample3, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample2, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample1, vec3(0.439216, -0.367788, -0.071427)) + 0.501961,
                            dot(sample4, vec3(0.439216, -0.367788, -0.071427)) + 0.501961);
    }
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

watershader = [
    spec = $arg2
    rgbfog = $arg3
    distort = $arg4
    combine = $arg5
    lazyshader 0 $arg1 [
        uniform vec4 camera, millis, waterheight;
        @(if $spec [result [uniform vec4 lightpos; varying vec3 lightdir;]])
        varying vec3 camdir;
        void main(void)
        {
            gl_Position = ftransform();
            gl_FrontColor = gl_Color;
            gl_TexCoord[0] = gl_TextureMatrix[0] * gl_Vertex;
            @(if (>= (strstr $arg1 "underwater") 0) [result [
                gl_TexCoord[0].z = waterheight.x - gl_Vertex.z;
            ]] [result [
                gl_TexCoord[0].z = gl_Vertex.z - waterheight.x;
            ]])
            vec2 tc = gl_MultiTexCoord0.xy * 0.1;
            gl_TexCoord[1].xy = tc + millis.x*0.04;
            gl_TexCoord[2].xy = tc - millis.x*0.02;
            camdir = camera.xyz - gl_Vertex.xyz;
            @(if $spec [result [
                lightdir = lightpos.xyz - gl_Vertex.xyz;
            ]])
        }
    ] [
        @(if $rgbfog [result [
            #pragma CUBE2_fog
        ]] [result [
            #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
        ]])
        uniform vec4 depth;
        @(if $spec [result [uniform vec4 lightcolor, lightradius; varying vec3 lightdir;]])
        varying vec3 camdir;
        @(if (>= (strstr $arg1 "env") 0) [result [
            uniform samplerCube tex0;
        ]] [result [
            uniform sampler2D tex0;
        ]]) 
        uniform sampler2D tex1, tex2, tex3;
        void main(void)
        {
            vec3 camvec = normalize(camdir);
            @(if $spec [result [
                vec3 lightvec = normalize(lightdir);
                vec3 halfangle = normalize(camvec + lightvec);
            ]])
                
            vec2 dudv = texture2D(tex2, gl_TexCoord[1].xy).xy*2.0 - 1.0;
        
            @distort
            
            @(if $spec [result [
                float spec = pow(clamp(dot(halfangle, bump), 0.0, 1.0), 96.0);
                vec3 light = lightcolor.xyz * (1.0 - clamp(length(lightdir)/lightradius.x, 0.0, 1.0));
            ]])

            @combine
        }
    ]
]

lazyshader 0 "underwater" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
    }
] [
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform vec4 depth;
    void main(void)
    {    
        gl_FragColor.rgb = 0.8*depth.x*gl_Color.rgb;
        gl_FragColor.a = 0.5*depth.y; 
    }
]

watershader "underwaterrefract" 0 1 [
    dudv = texture2D(tex2, gl_TexCoord[2].xy + 0.025*dudv).xy*2.0 - 1.0;

    gl_FragColor = texture2D(tex3, gl_TexCoord[0].xy/gl_TexCoord[0].w + 0.01*dudv);
] []
watershader "underwaterrefractfast" 0 1 [
    gl_FragColor = texture2DProj(tex3, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0));
] []
fastshader underwaterrefract underwaterrefractfast 2
altshader underwaterrefract underwaterrefractfast

watershader "underwaterfade" 0 1 [
    dudv = texture2D(tex2, gl_TexCoord[2].xy + 0.025*dudv).xy*2.0 - 1.0;

    vec2 projtc = gl_TexCoord[0].xy/gl_TexCoord[0].w;
    float fade = gl_TexCoord[0].z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
    gl_FragColor.rgb = texture2D(tex3, projtc + 0.01*dudv).rgb; 
] []
watershader "underwaterfadefast" 0 1 [
    gl_FragColor.rgb = texture2DProj(tex3, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    gl_FragColor.a = gl_TexCoord[0].z + 4.0*texture2DProj(tex3, gl_TexCoord[0]).a;
] []
fastshader underwaterfade underwaterfadefast 2
altshader underwaterfade underwaterfadefast

watershader "water" 1 0 [
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = gl_Color.rgb*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterfast" 0 0 [
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [    
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = gl_Color.rgb*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y;
]
fastshader water waterfast 1
altshader water waterfast

watershader "waterreflect" 1 0 [
    vec3 reflect = texture2DProj(tex0, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, gl_Color.rgb*depth.x, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterreflectfast" 0 0 [
    vec3 reflect = texture2DProj(tex0, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, gl_Color.rgb*depth.x, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y;
]
fastshader waterreflect waterreflectfast 2
altshader waterreflect waterreflectfast

watershader "waterrefract" 1 1 [
    vec2 dtc = gl_TexCoord[2].xy + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 rtc = gl_TexCoord[0].xy/gl_TexCoord[0].w + 0.01*dudv;
    vec3 reflect = texture2D(tex0, rtc).rgb;
    vec3 refract = texture2D(tex3, rtc).rgb;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterrefractfast" 0 1 [
    vec4 rtc = gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0);
    vec3 reflect = texture2DProj(tex0, rtc).rgb;
    vec3 refract = texture2DProj(tex3, rtc).rgb;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterrefract waterrefractfast 2
altshader waterrefract waterrefractfast

watershader "waterfade" 1 1 [
    vec2 dtc = gl_TexCoord[2].xy + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 projtc = gl_TexCoord[0].xy/gl_TexCoord[0].w;
    vec2 rtc = projtc + 0.01*dudv;
    vec3 reflect = texture2D(tex0, rtc).rgb;
    vec3 refract = texture2D(tex3, rtc).rgb;
    float fade = gl_TexCoord[0].z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
] [
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]   
watershader "waterfadefast" 0 1 [
    vec4 rtc = gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0);
    vec3 reflect = texture2DProj(tex0, rtc).rgb;
    vec3 refract = texture2DProj(tex3, rtc).rgb;
    gl_FragColor.a = gl_TexCoord[0].z + 4.0*texture2DProj(tex3, gl_TexCoord[0]).a;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
] [ 
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterfade waterfadefast 2
altshader waterfade waterrefract

watershader "waterenv" 1 0 [
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, gl_Color.rgb*depth.x, invfresnel*0.5+0.5) + spec*light;
    gl_FragColor.a = invfresnel*depth.y; 
]
watershader "waterenvfast" 0 0 [
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, gl_Color.rgb*depth.x, invfresnel*0.5+0.5);
    gl_FragColor.a = invfresnel*depth.y; 
]
fastshader waterenv waterenvfast 2
altshader waterenv waterenvfast

watershader "waterenvrefract" 1 1 [
    vec2 dtc = gl_TexCoord[2].xy + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec3 refract = texture2D(tex3, gl_TexCoord[0].xy/gl_TexCoord[0].w + 0.01*dudv).rgb;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterenvrefractfast" 0 1 [
    vec3 refract = texture2DProj(tex3, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterenvrefract waterenvrefractfast 2
altshader waterenvrefract waterenvrefractfast

watershader "waterenvfade" 1 1 [
    vec2 dtc = gl_TexCoord[2].xy + 0.025*dudv;
    vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
    dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

    vec2 projtc = gl_TexCoord[0].xy/gl_TexCoord[0].w;
    vec3 refract = texture2D(tex3, projtc + 0.01*dudv).rgb;
    float fade = gl_TexCoord[0].z + 4.0*texture2D(tex3, projtc).a;
    gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);

    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]
watershader "waterenvfadefast" 0 1 [
    vec3 refract = texture2DProj(tex3, gl_TexCoord[0] + vec4(0.4*dudv, 0.0, 0.0)).rgb;
    gl_FragColor.a = gl_TexCoord[0].z + 4.0*texture2DProj(tex3, gl_TexCoord[0]).a;
    vec3 bump = texture2D(tex1, gl_TexCoord[2].xy + 0.025*dudv).rgb*2.0 - 1.0;
    float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0); 
    vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
    gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterenvfade waterenvfadefast 2
altshader waterenvfade waterenvrefract

causticshader = [
    lazyshader 0 $arg1 [
        #pragma CUBE2_fog
        uniform vec4 texgenS, texgenT;
        void main(void)
        {
            gl_Position = ftransform();
            gl_TexCoord[0].xy = vec2(dot(texgenS.xyz, gl_Vertex.xyz), dot(texgenT.xyz, gl_Vertex.xyz)); 
        }
    ] [
        uniform vec4 frameoffset;
        uniform sampler2D tex0, tex1;
        void main(void)
        {
            @arg2
        }
    ]
]
causticshader caustic [
    gl_FragColor = frameoffset.x*texture2D(tex0, gl_TexCoord[0].xy) + frameoffset.y*texture2D(tex1, gl_TexCoord[0].xy);
]
causticshader causticfast [
    gl_FragColor = frameoffset.z*texture2D(tex0, gl_TexCoord[0].xy);
]
fastshader caustic causticfast 2

lazyshader 0 "lava" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        gl_FragColor = gl_Color * texture2D(tex0, gl_TexCoord[0].xy) * 2.0; 
    }
]

lazyshader 0 "waterfallrefract" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        gl_TexCoord[1] = gl_TextureMatrix[0] * gl_Vertex; 
    }
] [
    uniform vec4 dudvoffset;
    uniform sampler2D tex0, tex2, tex4;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        vec2 dudv = texture2D(tex2, gl_TexCoord[0].xy + 0.2*diffuse.xy + dudvoffset.xy).xy; 
        vec4 refract = texture2DProj(tex4, gl_TexCoord[1] + vec4(4.0*dudv, 0.0, 0.0));
        gl_FragColor = mix(refract, gl_Color, diffuse);
    }
]

lazyshader 0 "waterfallenvrefract" [
    #pragma CUBE2_fog
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        gl_TexCoord[1] = gl_TextureMatrix[0] * gl_Vertex;
        camdir = camera.xyz - gl_Vertex.xyz;
        vec3 absnorm = abs(gl_Normal);
        world = mat3(absnorm.yzx, -absnorm.zxy, gl_Normal);
    }
] [
    uniform vec4 dudvoffset;
    uniform sampler2D tex0, tex1, tex2, tex4;
    uniform samplerCube tex3;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        vec2 dudv = texture2D(tex2, gl_TexCoord[0].xy + 0.2*diffuse.xy + dudvoffset.xy).xy; 
        vec3 normal = world * (texture2D(tex1, gl_TexCoord[0].xy + 0.1*dudv).rgb*2.0 - 1.0);
        vec4 refract = texture2DProj(tex4, gl_TexCoord[1] + vec4(4.0*dudv, 0.0, 0.0));
        vec3 camvec = normalize(camdir);
        float invfresnel = dot(normal, camvec);
        vec4 reflect = textureCube(tex3, 2.0*invfresnel*normal - camvec);
        gl_FragColor = mix(mix(reflect, refract, 1.0 - 0.4*step(0.0, invfresnel)), gl_Color, diffuse); 
    }
]
altshader waterfallenvrefract waterfallrefract

lazyshader 0 "waterfallenv" [
    #pragma CUBE2_fog
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        camdir = camera.xyz - gl_Vertex.xyz;
        vec3 absnorm = abs(gl_Normal);
        world = mat3(absnorm.yzx, -absnorm.zxy, gl_Normal);
    }
] [
    uniform vec4 dudvoffset;
    uniform sampler2D tex0, tex1, tex2;
    uniform samplerCube tex3;
    varying vec3 camdir;
    varying mat3 world; 
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        vec2 dudv = texture2D(tex2, gl_TexCoord[0].xy + 0.2*diffuse.xy + dudvoffset.xy).xy; 
        vec3 normal = world * (texture2D(tex1, gl_TexCoord[0].xy + 0.1*dudv).rgb*2.0 - 1.0);
        vec3 camvec = normalize(camdir);
        vec4 reflect = textureCube(tex3, 2.0*dot(normal, camvec)*normal - camvec);
        gl_FragColor.rgb = mix(reflect.rgb, gl_Color.rgb, diffuse.rgb);
        gl_FragColor.a = 0.25 + 0.75*diffuse.r;    
    }
]

lazyshader 0 "glass" [
    uniform vec4 camera;
    varying vec3 rvec, camdir, normal;
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        rvec = gl_MultiTexCoord0.xyz;
        camdir = camera.xyz - gl_Vertex.xyz;
        normal = gl_Normal;
    }
] [ 
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform samplerCube tex0;
    varying vec3 rvec, camdir, normal;
    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 reflect = textureCube(tex0, rvec).rgb;
   
        float invfresnel = max(dot(camvec, normal), 0.70); 
        gl_FragColor.rgb = mix(reflect, gl_Color.rgb*0.05, invfresnel);
        gl_FragColor.a = invfresnel * 0.95;
    }
]
lazyshader 0 "glassfast" [
    varying vec3 rvec;
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        rvec = gl_MultiTexCoord0.xyz;
    }
] [ 
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 1.0)
    uniform samplerCube tex0;
    varying vec3 rvec;
    void main(void)
    {
        vec3 reflect = textureCube(tex0, rvec).rgb;
        const float invfresnel = 0.75;
        gl_FragColor.rgb = mix(reflect, gl_Color.rgb*0.05, invfresnel);
        gl_FragColor.a = invfresnel * 0.95; 
    }
]
fastshader glass glassfast 2
altshader glass glassfast

lazyshader 0 "grass" [
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
        gl_TexCoord[1].xy = gl_MultiTexCoord1.xy;
    }
] [
    #pragma CUBE2_fogrgba vec4(0.0, 0.0, 0.0, 0.0)
    uniform sampler2D tex0, tex1;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        diffuse.rgb *= 2.0;
        vec4 lm = texture2D(tex1, gl_TexCoord[1].xy) * gl_Color;
        lm.rgb *= lm.a;
        gl_FragColor = diffuse * lm;
    }
]

shader 0 "overbrightdecal" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        gl_FragColor = mix(gl_Color, diffuse, gl_Color.a);
    }
]

shader 0 "saturatedecal" [
    #pragma CUBE2_fog
    void main(void)
    {
        gl_Position = ftransform();
        gl_FrontColor = gl_Color;
        gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    }
] [
    uniform sampler2D tex0;
    void main(void)
    {
        vec4 diffuse = texture2D(tex0, gl_TexCoord[0].xy);
        diffuse.rgb *= 2.0;
        gl_FragColor = diffuse * gl_Color;
    }
]

